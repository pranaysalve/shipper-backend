{"version":3,"file":"index.mjs","sources":["../../src/entity-manager/index.ts"],"sourcesContent":["import {\n  castArray,\n  compact,\n  difference,\n  differenceWith,\n  has,\n  isArray,\n  isEmpty,\n  isEqual,\n  isInteger,\n  isNil,\n  isNull,\n  isNumber,\n  isObject,\n  isPlainObject,\n  isString,\n  isUndefined,\n  map,\n  pick,\n  uniqBy,\n  uniqWith,\n} from 'lodash/fp';\n\nimport * as types from '../utils/types';\nimport { createField } from '../fields';\nimport { createQueryBuilder } from '../query';\nimport { createRepository } from './entity-repository';\nimport {\n  deleteRelatedMorphOneRelationsAfterMorphToManyUpdate,\n  encodePolymorphicRelation,\n  encodePolymorphicId,\n} from './morph-relations';\nimport {\n  isBidirectional,\n  isAnyToOne,\n  isOneToAny,\n  hasOrderColumn,\n  hasInverseOrderColumn,\n} from '../metadata';\nimport {\n  deletePreviousOneToAnyRelations,\n  deletePreviousAnyToOneRelations,\n  deleteRelations,\n  cleanOrderColumns,\n} from './regular-relations';\nimport { relationsOrderer } from './relations-orderer';\nimport type { Database } from '..';\nimport type { Meta } from '../metadata';\nimport type { ID } from '../types';\nimport { EntityManager, Repository, Entity } from './types';\n\nexport * from './types';\n\nconst isRecord = (value: unknown): value is Record<string, unknown> =>\n  isObject(value) && !isNil(value);\n\nconst toId = (value: unknown | { id: unknown }): ID => {\n  if (isRecord(value) && 'id' in value && isValidId(value.id)) {\n    return value.id;\n  }\n\n  if (isValidId(value)) {\n    return value;\n  }\n\n  throw new Error(`Invalid id, expected a string or integer, got ${JSON.stringify(value)}`);\n};\nconst toIds = (value: unknown): ID[] => castArray(value || []).map(toId);\n\nconst isValidId = (value: unknown): value is ID => isString(value) || isInteger(value);\n\nconst isValidObjectId = (value: unknown): value is Entity =>\n  isRecord(value) && 'id' in value && isValidId(value.id);\n\nconst toIdArray = (\n  data: unknown\n): {\n  id: ID;\n  __pivot?: { [key: string]: any };\n  [key: string]: any;\n}[] => {\n  const array = castArray(data)\n    .filter((datum) => !isNil(datum))\n    .map((datum) => {\n      // if it is a string or an integer return an obj with id = to datum\n      if (isValidId(datum)) {\n        return { id: datum, __pivot: {} };\n      }\n\n      // if it is an object check it has at least a valid id\n      if (!isValidObjectId(datum)) {\n        throw new Error(`Invalid id, expected a string or integer, got ${datum}`);\n      }\n\n      return datum;\n    });\n\n  return uniqWith(isEqual, array);\n};\n\ntype ScalarAssoc = string | number | null;\ntype Assocs =\n  | ScalarAssoc\n  | { id: ScalarAssoc | Array<ScalarAssoc> }\n  | Array<ScalarAssoc>\n  | {\n      set?: Array<ScalarAssoc> | null;\n      options?: { strict?: boolean };\n      connect?: Array<{\n        id: ScalarAssoc;\n        position?: { start?: boolean; end?: boolean; before?: ID; after?: ID };\n        __pivot?: any;\n        __type?: any;\n      }> | null;\n      disconnect?: Array<ScalarAssoc> | null;\n    };\n\nconst toAssocs = (data: Assocs) => {\n  if (\n    isArray(data) ||\n    isString(data) ||\n    isNumber(data) ||\n    isNull(data) ||\n    (isRecord(data) && 'id' in data)\n  ) {\n    return {\n      set: isNull(data) ? data : toIdArray(data),\n    };\n  }\n\n  if (data?.set) {\n    return {\n      set: isNull(data.set) ? data.set : toIdArray(data.set),\n    };\n  }\n\n  return {\n    options: {\n      strict: data?.options?.strict,\n    },\n    connect: toIdArray(data?.connect).map((elm) => ({\n      id: elm.id,\n      position: elm.position ? elm.position : { end: true },\n      __pivot: elm.__pivot ?? {},\n      __type: elm.__type,\n    })),\n    disconnect: toIdArray(data?.disconnect),\n  };\n};\n\nconst processData = (\n  metadata: Meta,\n  data: Record<string, unknown> = {},\n  { withDefaults = false } = {}\n) => {\n  const { attributes } = metadata;\n\n  const obj: Record<string, unknown> = {};\n\n  for (const attributeName of Object.keys(attributes)) {\n    const attribute = attributes[attributeName];\n\n    if (types.isScalarAttribute(attribute)) {\n      const field = createField(attribute);\n\n      if (isUndefined(data[attributeName])) {\n        if (!isUndefined(attribute.default) && withDefaults) {\n          if (typeof attribute.default === 'function') {\n            obj[attributeName] = attribute.default();\n          } else {\n            obj[attributeName] = attribute.default;\n          }\n        }\n        continue;\n      }\n\n      if (\n        'validate' in field &&\n        typeof field.validate === 'function' &&\n        data[attributeName] !== null\n      ) {\n        field.validate(data[attributeName]);\n      }\n\n      const val = data[attributeName] === null ? null : field.toDB(data[attributeName]);\n\n      obj[attributeName] = val;\n    }\n\n    if (types.isRelationalAttribute(attribute)) {\n      // oneToOne & manyToOne\n      if ('joinColumn' in attribute && attribute.joinColumn && attribute.owner) {\n        const joinColumnName = attribute.joinColumn.name;\n\n        // allow setting to null\n        const attrValue = !isUndefined(data[attributeName])\n          ? data[attributeName]\n          : data[joinColumnName];\n\n        if (isNull(attrValue)) {\n          obj[joinColumnName] = attrValue;\n        } else if (!isUndefined(attrValue)) {\n          obj[joinColumnName] = toId(attrValue);\n        }\n\n        continue;\n      }\n\n      if ('morphColumn' in attribute && attribute.morphColumn && attribute.owner) {\n        const { idColumn, typeColumn, typeField = '__type' } = attribute.morphColumn;\n\n        const value = data[attributeName] as Record<string, unknown>;\n\n        if (value === null) {\n          Object.assign(obj, {\n            [idColumn.name]: null,\n            [typeColumn.name]: null,\n          });\n\n          continue;\n        }\n\n        if (!isUndefined(value)) {\n          if (!has('id', value) || !has(typeField, value)) {\n            throw new Error(`Expects properties ${typeField} an id to make a morph association`);\n          }\n\n          Object.assign(obj, {\n            [idColumn.name]: value.id,\n            [typeColumn.name]: value[typeField],\n          });\n        }\n      }\n    }\n  }\n\n  return obj;\n};\nexport const createEntityManager = (db: Database): EntityManager => {\n  const repoMap: Record<string, Repository> = {};\n\n  return {\n    async findOne(uid, params) {\n      const states = await db.lifecycles.run('beforeFindOne', uid, { params });\n\n      const result = await this.createQueryBuilder(uid)\n        .init(params)\n        .first()\n        .execute<Entity | null>();\n\n      await db.lifecycles.run('afterFindOne', uid, { params, result }, states);\n\n      return result;\n    },\n\n    // should we name it findOne because people are used to it ?\n    async findMany(uid, params) {\n      const states = await db.lifecycles.run('beforeFindMany', uid, { params });\n\n      const result = await this.createQueryBuilder(uid).init(params).execute<any[]>();\n\n      await db.lifecycles.run('afterFindMany', uid, { params, result }, states);\n\n      return result;\n    },\n\n    async count(uid, params = {}) {\n      const states = await db.lifecycles.run('beforeCount', uid, { params });\n\n      const res = await this.createQueryBuilder(uid)\n        .init(pick(['_q', 'where', 'filters'], params))\n        .count()\n        .first()\n        .execute<{ count: number }>();\n\n      const result = Number(res.count);\n\n      await db.lifecycles.run('afterCount', uid, { params, result }, states);\n\n      return result;\n    },\n\n    async create(uid, params = {}) {\n      const states = await db.lifecycles.run('beforeCreate', uid, { params });\n\n      const metadata = db.metadata.get(uid);\n      const { data } = params;\n\n      if (!isPlainObject(data)) {\n        throw new Error('Create expects a data object');\n      }\n\n      const dataToInsert = processData(metadata, data, { withDefaults: true });\n\n      const res = await this.createQueryBuilder(uid)\n        .insert(dataToInsert)\n        .execute<Array<ID | { id: ID }>>();\n\n      const id = isRecord(res[0]) ? res[0].id : res[0];\n\n      const trx = await strapi.db.transaction();\n      try {\n        await this.attachRelations(uid, id, data, { transaction: trx.get() });\n\n        await trx.commit();\n      } catch (e) {\n        await trx.rollback();\n        await this.createQueryBuilder(uid).where({ id }).delete().execute();\n        throw e;\n      }\n\n      // TODO: in case there is no select or populate specified return the inserted data ?\n      // TODO: do not trigger the findOne lifecycles ?\n      const result = await this.findOne(uid, {\n        where: { id },\n        select: params.select,\n        populate: params.populate,\n        filters: params.filters,\n      });\n\n      await db.lifecycles.run('afterCreate', uid, { params, result }, states);\n\n      return result;\n    },\n\n    // TODO: where do we handle relation processing for many queries ?\n    async createMany(uid, params = {}) {\n      const states = await db.lifecycles.run('beforeCreateMany', uid, { params });\n\n      const metadata = db.metadata.get(uid);\n      const { data } = params;\n\n      if (!isArray(data)) {\n        throw new Error('CreateMany expects data to be an array');\n      }\n\n      const dataToInsert = data.map((datum) =>\n        processData(metadata, datum, { withDefaults: true })\n      );\n\n      if (isEmpty(dataToInsert)) {\n        throw new Error('Nothing to insert');\n      }\n\n      const createdEntries = await this.createQueryBuilder(uid)\n        .insert(dataToInsert)\n        .execute<Array<ID | { id: ID }>>();\n\n      const result = {\n        count: data.length,\n        ids: createdEntries.map((entry) => (typeof entry === 'object' ? entry?.id : entry)),\n      };\n\n      await db.lifecycles.run('afterCreateMany', uid, { params, result }, states);\n\n      return result;\n    },\n\n    async update(uid, params = {}) {\n      const states = await db.lifecycles.run('beforeUpdate', uid, { params });\n\n      const metadata = db.metadata.get(uid);\n      const { where, data } = params;\n\n      if (!isPlainObject(data)) {\n        throw new Error('Update requires a data object');\n      }\n\n      if (isEmpty(where)) {\n        throw new Error('Update requires a where parameter');\n      }\n\n      const entity = await this.createQueryBuilder(uid)\n        .select('*')\n        .where(where)\n        .first()\n        .execute<{ id: ID }>({ mapResults: false });\n\n      if (!entity) {\n        return null;\n      }\n\n      const { id } = entity;\n\n      const dataToUpdate = processData(metadata, data);\n\n      if (!isEmpty(dataToUpdate)) {\n        await this.createQueryBuilder(uid).where({ id }).update(dataToUpdate).execute();\n      }\n\n      const trx = await strapi.db.transaction();\n      try {\n        await this.updateRelations(uid, id, data, { transaction: trx.get() });\n        await trx.commit();\n      } catch (e) {\n        await trx.rollback();\n        await this.createQueryBuilder(uid).where({ id }).update(entity).execute();\n        throw e;\n      }\n\n      // TODO: do not trigger the findOne lifecycles ?\n      const result = await this.findOne(uid, {\n        where: { id },\n        select: params.select,\n        populate: params.populate,\n        filters: params.filters,\n      });\n\n      await db.lifecycles.run('afterUpdate', uid, { params, result }, states);\n\n      return result;\n    },\n\n    // TODO: where do we handle relation processing for many queries ?\n    async updateMany(uid, params = {}) {\n      const states = await db.lifecycles.run('beforeUpdateMany', uid, { params });\n\n      const metadata = db.metadata.get(uid);\n      const { where, data } = params;\n\n      const dataToUpdate = processData(metadata, data);\n\n      if (isEmpty(dataToUpdate)) {\n        throw new Error('Update requires data');\n      }\n\n      const updatedRows = await this.createQueryBuilder(uid)\n        .where(where)\n        .update(dataToUpdate)\n        .execute<number>();\n\n      const result = { count: updatedRows };\n\n      await db.lifecycles.run('afterUpdateMany', uid, { params, result }, states);\n\n      return result;\n    },\n\n    async delete(uid, params = {}) {\n      const states = await db.lifecycles.run('beforeDelete', uid, { params });\n\n      const { where, select, populate } = params;\n\n      if (isEmpty(where)) {\n        throw new Error('Delete requires a where parameter');\n      }\n\n      // TODO: do not trigger the findOne lifecycles ?\n      const entity = await this.findOne(uid, {\n        select: select && ['id'].concat(select),\n        where,\n        populate,\n      });\n\n      if (!entity) {\n        return null;\n      }\n\n      const { id } = entity;\n\n      await this.createQueryBuilder(uid).where({ id }).delete().execute();\n\n      const trx = await strapi.db.transaction();\n      try {\n        await this.deleteRelations(uid, id, { transaction: trx.get() });\n\n        await trx.commit();\n      } catch (e) {\n        await trx.rollback();\n        throw e;\n      }\n\n      await db.lifecycles.run('afterDelete', uid, { params, result: entity }, states);\n\n      return entity;\n    },\n\n    // TODO: where do we handle relation processing for many queries ?\n    async deleteMany(uid, params = {}) {\n      const states = await db.lifecycles.run('beforeDeleteMany', uid, { params });\n\n      const { where } = params;\n\n      const deletedRows = await this.createQueryBuilder(uid)\n        .where(where)\n        .delete()\n        .execute<number>({ mapResults: false });\n\n      const result = { count: deletedRows };\n\n      await db.lifecycles.run('afterDeleteMany', uid, { params, result }, states);\n\n      return result;\n    },\n\n    /**\n     * Attach relations to a new entity\n     */\n    async attachRelations(uid, id, data, options) {\n      const { attributes } = db.metadata.get(uid);\n      const { transaction: trx } = options ?? {};\n\n      for (const attributeName of Object.keys(attributes)) {\n        const attribute = attributes[attributeName];\n\n        const isValidLink = has(attributeName, data) && !isNil(data[attributeName]);\n\n        if (attribute.type !== 'relation' || !isValidLink) {\n          continue;\n        }\n\n        const cleanRelationData = toAssocs(data[attributeName]);\n\n        if (attribute.relation === 'morphOne' || attribute.relation === 'morphMany') {\n          /**\n           * morphOne and morphMany relations\n           */\n          const { target, morphBy } = attribute;\n\n          const targetAttribute = db.metadata.get(target).attributes[morphBy];\n          if (targetAttribute.type !== 'relation') {\n            throw new Error(\n              `Expected target attribute ${target}.${morphBy} to be a relation attribute`\n            );\n          }\n\n          if (targetAttribute.relation === 'morphToOne') {\n            // set columns\n            const { idColumn, typeColumn } = targetAttribute.morphColumn;\n\n            const relId = toId(cleanRelationData.set?.[0]);\n\n            await this.createQueryBuilder(target)\n              .update({ [idColumn.name]: id, [typeColumn.name]: uid })\n              .where({ id: relId })\n              .transacting(trx)\n              .execute();\n          } else if (targetAttribute.relation === 'morphToMany') {\n            const { joinTable } = targetAttribute;\n            const { joinColumn, morphColumn } = joinTable;\n\n            const { idColumn, typeColumn } = morphColumn;\n\n            if (isEmpty(cleanRelationData.set)) {\n              continue;\n            }\n\n            const rows =\n              cleanRelationData.set?.map((data, idx) => {\n                return {\n                  [joinColumn.name]: data.id,\n                  [idColumn.name]: id,\n                  [typeColumn.name]: uid,\n                  ...(('on' in joinTable && joinTable.on) || {}),\n                  ...(data.__pivot || {}),\n                  order: idx + 1,\n                  field: attributeName,\n                };\n              }) ?? [];\n\n            await this.createQueryBuilder(joinTable.name).insert(rows).transacting(trx).execute();\n          }\n\n          continue;\n        } else if (attribute.relation === 'morphToOne') {\n          /**\n           * morphToOne\n           */\n          // handled on the entry itself\n          continue;\n        } else if (attribute.relation === 'morphToMany') {\n          /**\n           * morphToMany\n           */\n          const { joinTable } = attribute;\n          const { joinColumn, morphColumn } = joinTable;\n\n          const { idColumn, typeColumn, typeField = '__type' } = morphColumn;\n\n          if (isEmpty(cleanRelationData.set) && isEmpty(cleanRelationData.connect)) {\n            continue;\n          }\n\n          // set happens before connect/disconnect\n          const dataset = cleanRelationData.set || cleanRelationData.connect || [];\n\n          const rows = dataset.map((data, idx) => ({\n            [joinColumn.name]: id,\n            [idColumn.name]: data.id,\n            [typeColumn.name]: data[typeField as '__type'],\n            ...(('on' in joinTable && joinTable.on) || {}),\n            ...(data.__pivot || {}),\n            order: idx + 1,\n          })) satisfies Record<string, any>[];\n\n          const orderMap = relationsOrderer(\n            [],\n            morphColumn.idColumn.name,\n            'order',\n            true // Always make a strict connect when inserting\n          )\n            .connect(\n              // Merge id & __type to get a single id key\n              dataset.map(encodePolymorphicRelation({ idColumn: 'id', typeColumn: typeField }))\n            )\n            .get()\n            // set the order based on the order of the ids\n            .reduce((acc, rel, idx) => ({ ...acc, [rel.id]: idx + 1 }), {} as Record<ID, number>);\n\n          rows.forEach((row: Record<string, unknown>) => {\n            const rowId = row[morphColumn.idColumn.name] as ID;\n            const rowType = row[morphColumn.typeColumn.name] as string;\n            const encodedId = encodePolymorphicId(rowId, rowType);\n\n            row.order = orderMap[encodedId];\n          });\n\n          // delete previous relations\n          await deleteRelatedMorphOneRelationsAfterMorphToManyUpdate(rows as any, {\n            uid,\n            attributeName,\n            joinTable,\n            db,\n            transaction: trx,\n          });\n\n          await this.createQueryBuilder(joinTable.name).insert(rows).transacting(trx).execute();\n\n          continue;\n        }\n\n        if ('joinColumn' in attribute && attribute.joinColumn && attribute.owner) {\n          const relIdsToAdd = toIds(cleanRelationData.set);\n          if (\n            attribute.relation === 'oneToOne' &&\n            isBidirectional(attribute) &&\n            relIdsToAdd.length\n          ) {\n            await this.createQueryBuilder(uid)\n              .where({ [attribute.joinColumn.name]: relIdsToAdd, id: { $ne: id } })\n              .update({ [attribute.joinColumn.name]: null })\n              .transacting(trx)\n              .execute();\n          }\n\n          continue;\n        }\n\n        // oneToOne oneToMany on the non owning side\n        if ('joinColumn' in attribute && attribute.joinColumn && !attribute.owner) {\n          // need to set the column on the target\n          const { target } = attribute;\n\n          // TODO: check it is an id & the entity exists (will throw due to FKs otherwise so not a big pbl in SQL)\n          const relIdsToAdd = toIds(cleanRelationData.set);\n\n          await this.createQueryBuilder(target)\n            .where({ [attribute.joinColumn.referencedColumn]: id })\n            .update({ [attribute.joinColumn.referencedColumn]: null })\n            .transacting(trx)\n            .execute();\n\n          await this.createQueryBuilder(target)\n            .update({ [attribute.joinColumn.referencedColumn]: id })\n            // NOTE: works if it is an array or a single id\n            .where({ id: relIdsToAdd })\n            .transacting(trx)\n            .execute();\n        }\n\n        if ('joinTable' in attribute && attribute.joinTable) {\n          // need to set the column on the target\n\n          const { joinTable } = attribute;\n          const { joinColumn, inverseJoinColumn, orderColumnName, inverseOrderColumnName } =\n            joinTable;\n\n          const relsToAdd = (cleanRelationData.set || cleanRelationData.connect) ?? [];\n          const relIdsToadd = toIds(relsToAdd);\n\n          if (isBidirectional(attribute) && isOneToAny(attribute)) {\n            await deletePreviousOneToAnyRelations({\n              id,\n              attribute,\n              relIdsToadd,\n              db,\n              transaction: trx,\n            });\n          }\n\n          // prepare new relations to insert\n          const insert = uniqBy('id', relsToAdd).map((data) => {\n            return {\n              [joinColumn.name]: id,\n              [inverseJoinColumn.name]: data.id,\n              ...(('on' in joinTable && joinTable.on) || {}),\n              ...(data.__pivot || {}),\n            };\n          }) satisfies Record<string, any>[];\n\n          // add order value\n          if (cleanRelationData.set && hasOrderColumn(attribute)) {\n            insert.forEach((data: Record<string, unknown>, idx) => {\n              data[orderColumnName] = idx + 1;\n            });\n          } else if (cleanRelationData.connect && hasOrderColumn(attribute)) {\n            // use position attributes to calculate order\n            const orderMap = relationsOrderer(\n              [],\n              inverseJoinColumn.name,\n              joinTable.orderColumnName,\n              true // Always make an strict connect when inserting\n            )\n              .connect(relsToAdd)\n              .get()\n              // set the order based on the order of the ids\n              .reduce((acc, rel, idx) => ({ ...acc, [rel.id]: idx }), {} as Record<ID, number>);\n\n            insert.forEach((row: Record<string, unknown>) => {\n              row[orderColumnName] = orderMap[row[inverseJoinColumn.name] as number];\n            });\n          }\n\n          // add inv_order value\n          if (hasInverseOrderColumn(attribute)) {\n            const maxResults = await db\n              .getConnection()\n              .select(inverseJoinColumn.name)\n              .max(inverseOrderColumnName, { as: 'max' })\n              .whereIn(inverseJoinColumn.name, relIdsToadd)\n              .where(joinTable.on || {})\n              .groupBy(inverseJoinColumn.name)\n              .from(joinTable.name)\n              .transacting(trx);\n\n            const maxMap = maxResults.reduce(\n              (acc, res) => Object.assign(acc, { [res[inverseJoinColumn.name]]: res.max }),\n              {} as Record<string, number>\n            );\n\n            insert.forEach((rel) => {\n              rel[inverseOrderColumnName] = (maxMap[rel[inverseJoinColumn.name]] || 0) + 1;\n            });\n          }\n\n          if (insert.length === 0) {\n            continue;\n          }\n\n          // insert new relations\n          await this.createQueryBuilder(joinTable.name).insert(insert).transacting(trx).execute();\n        }\n      }\n    },\n\n    /**\n     * Updates relations of an existing entity\n     */\n    // TODO: check relation exists (handled by FKs except for polymorphics)\n    async updateRelations(uid, id, data, options) {\n      const { attributes } = db.metadata.get(uid);\n      const { transaction: trx } = options ?? {};\n\n      for (const attributeName of Object.keys(attributes)) {\n        const attribute = attributes[attributeName];\n\n        if (attribute.type !== 'relation' || !has(attributeName, data)) {\n          continue;\n        }\n        const cleanRelationData = toAssocs(data[attributeName]);\n\n        if (attribute.relation === 'morphOne' || attribute.relation === 'morphMany') {\n          const { target, morphBy } = attribute;\n\n          const targetAttribute = db.metadata.get(target).attributes[morphBy];\n\n          if (targetAttribute.type === 'relation' && targetAttribute.relation === 'morphToOne') {\n            // set columns\n            const { idColumn, typeColumn } = targetAttribute.morphColumn;\n\n            // update instead of deleting because the relation is directly on the entity table\n            // and not in a join table\n            await this.createQueryBuilder(target)\n              .update({ [idColumn.name]: null, [typeColumn.name]: null })\n              .where({ [idColumn.name]: id, [typeColumn.name]: uid })\n              .transacting(trx)\n              .execute();\n\n            if (!isNull(cleanRelationData.set)) {\n              const relId = toIds(cleanRelationData.set?.[0]);\n              await this.createQueryBuilder(target)\n                .update({ [idColumn.name]: id, [typeColumn.name]: uid })\n                .where({ id: relId })\n                .transacting(trx)\n                .execute();\n            }\n          } else if (\n            targetAttribute.type === 'relation' &&\n            targetAttribute.relation === 'morphToMany'\n          ) {\n            const { joinTable } = targetAttribute;\n            const { joinColumn, morphColumn } = joinTable;\n\n            const { idColumn, typeColumn } = morphColumn;\n\n            const hasSet = !isEmpty(cleanRelationData.set);\n            const hasConnect = !isEmpty(cleanRelationData.connect);\n            const hasDisconnect = !isEmpty(cleanRelationData.disconnect);\n\n            // for connect/disconnect without a set, only modify those relations\n            if (!hasSet && (hasConnect || hasDisconnect)) {\n              // delete disconnects and connects (to prevent duplicates when we add them later)\n              const idsToDelete = [\n                ...(cleanRelationData.disconnect || []),\n                ...(cleanRelationData.connect || []),\n              ];\n\n              if (!isEmpty(idsToDelete)) {\n                const where = {\n                  $or: idsToDelete.map((item: any) => {\n                    return {\n                      [idColumn.name]: id,\n                      [typeColumn.name]: uid,\n                      [joinColumn.name]: item.id,\n                      ...(joinTable.on || {}),\n                      field: attributeName,\n                    };\n                  }),\n                };\n\n                await this.createQueryBuilder(joinTable.name)\n                  .delete()\n                  .where(where)\n                  .transacting(trx)\n                  .execute();\n              }\n\n              // connect relations\n              if (hasConnect) {\n                // Query database to find the order of the last relation\n                const start = await this.createQueryBuilder(joinTable.name)\n                  .where({\n                    [idColumn.name]: id,\n                    [typeColumn.name]: uid,\n                    ...(joinTable.on || {}),\n                    ...(data.__pivot || {}),\n                  })\n                  .max('order')\n                  .first()\n                  .transacting(trx)\n                  .execute();\n\n                const startOrder = (start as any)?.max || 0;\n\n                const rows = (cleanRelationData.connect ?? []).map((data, idx) => ({\n                  [joinColumn.name]: data.id,\n                  [idColumn.name]: id,\n                  [typeColumn.name]: uid,\n                  ...(joinTable.on || {}),\n                  ...(data.__pivot || {}),\n                  order: startOrder + idx + 1,\n                  field: attributeName,\n                })) satisfies Record<string, any>[];\n\n                await this.createQueryBuilder(joinTable.name)\n                  .insert(rows)\n                  .transacting(trx)\n                  .execute();\n              }\n\n              continue;\n            }\n\n            // delete all relations\n            await this.createQueryBuilder(joinTable.name)\n              .delete()\n              .where({\n                [idColumn.name]: id,\n                [typeColumn.name]: uid,\n                ...(joinTable.on || {}),\n                field: attributeName,\n              })\n              .transacting(trx)\n              .execute();\n\n            if (hasSet) {\n              const rows = (cleanRelationData.set ?? []).map((data, idx) => ({\n                [joinColumn.name]: data.id,\n                [idColumn.name]: id,\n                [typeColumn.name]: uid,\n                ...(joinTable.on || {}),\n                ...(data.__pivot || {}),\n                order: idx + 1,\n                field: attributeName,\n              })) satisfies Record<string, any>[];\n\n              await this.createQueryBuilder(joinTable.name).insert(rows).transacting(trx).execute();\n            }\n          }\n\n          continue;\n        }\n\n        if (attribute.relation === 'morphToOne') {\n          // handled on the entry itself\n          continue;\n        }\n\n        if (attribute.relation === 'morphToMany') {\n          const { joinTable } = attribute;\n          const { joinColumn, morphColumn } = joinTable;\n\n          const { idColumn, typeColumn, typeField = '__type' } = morphColumn;\n\n          const hasSet = !isEmpty(cleanRelationData.set);\n          const hasConnect = !isEmpty(cleanRelationData.connect);\n          const hasDisconnect = !isEmpty(cleanRelationData.disconnect);\n\n          // for connect/disconnect without a set, only modify those relations\n          if (!hasSet && (hasConnect || hasDisconnect)) {\n            // delete disconnects and connects (to prevent duplicates when we add them later)\n            const idsToDelete = [\n              ...(cleanRelationData.disconnect || []),\n              ...(cleanRelationData.connect || []),\n            ];\n\n            const rowsToDelete = [\n              ...(cleanRelationData.disconnect ?? []).map((data, idx) => ({\n                [joinColumn.name]: id,\n                [idColumn.name]: data.id,\n                [typeColumn.name]: data[typeField],\n                ...(('on' in joinTable && joinTable.on) || {}),\n                ...(data.__pivot || {}),\n                order: idx + 1,\n              })),\n              ...(cleanRelationData.connect ?? []).map((data, idx) => ({\n                [joinColumn.name]: id,\n                [idColumn.name]: data.id,\n                // @ts-expect-error TODO\n                [typeColumn.name]: data[typeField],\n                ...(('on' in joinTable && joinTable.on) || {}),\n                ...(data.__pivot || {}),\n                order: idx + 1,\n              })),\n            ];\n\n            const adjacentRelations = await this.createQueryBuilder(joinTable.name)\n              .where({\n                $or: [\n                  {\n                    [joinColumn.name]: id,\n                    [idColumn.name]: {\n                      $in: compact(\n                        cleanRelationData.connect?.map(\n                          (r) => r.position?.after || r.position?.before\n                        )\n                      ),\n                    },\n                  },\n                  {\n                    [joinColumn.name]: id,\n                    order: this.createQueryBuilder(joinTable.name)\n                      .max('order')\n                      .where({ [joinColumn.name]: id })\n                      .where(joinTable.on || {})\n                      .transacting(trx)\n                      .getKnexQuery(),\n                  },\n                ],\n              })\n              .where(joinTable.on || {})\n              .transacting(trx)\n              .execute<Array<Record<string, any>>>();\n\n            if (!isEmpty(idsToDelete)) {\n              const where = {\n                $or: idsToDelete.map((item: any) => {\n                  return {\n                    [idColumn.name]: item.id,\n                    [typeColumn.name]: item[typeField],\n                    [joinColumn.name]: id,\n                    ...(joinTable.on || {}),\n                  };\n                }),\n              };\n\n              // delete previous relations\n              await this.createQueryBuilder(joinTable.name)\n                .delete()\n                .where(where)\n                .transacting(trx)\n                .execute();\n\n              await deleteRelatedMorphOneRelationsAfterMorphToManyUpdate(rowsToDelete as any, {\n                uid,\n                attributeName,\n                joinTable,\n                db,\n                transaction: trx,\n              });\n            }\n\n            // connect relations\n            if (hasConnect) {\n              const dataset = cleanRelationData.connect || [];\n\n              const rows = dataset.map((data) => ({\n                [joinColumn.name]: id,\n                [idColumn.name]: data.id,\n                [typeColumn.name]: data[typeField as '__type'],\n                ...(joinTable.on || {}),\n                ...(data.__pivot || {}),\n                field: attributeName,\n              })) satisfies Record<string, any>[];\n\n              const orderMap = relationsOrderer(\n                // Merge id & __type to get a single id key\n                adjacentRelations.map(\n                  encodePolymorphicRelation({\n                    idColumn: idColumn.name,\n                    typeColumn: typeColumn.name,\n                  })\n                ),\n                idColumn.name,\n                'order',\n                cleanRelationData.options?.strict\n              )\n                .connect(\n                  // Merge id & __type to get a single id key\n                  dataset.map(encodePolymorphicRelation({ idColumn: 'id', typeColumn: '__type' }))\n                )\n                .getOrderMap();\n\n              rows.forEach((row: Record<string, unknown>) => {\n                const rowId = row[idColumn.name] as number;\n                const rowType = row[typeColumn.name] as string;\n                const encodedId = encodePolymorphicId(rowId, rowType);\n\n                row.order = orderMap[encodedId];\n              });\n\n              await this.createQueryBuilder(joinTable.name).insert(rows).transacting(trx).execute();\n            }\n\n            continue;\n          }\n\n          if (hasSet) {\n            // delete all relations for this entity\n            await this.createQueryBuilder(joinTable.name)\n              .delete()\n              .where({\n                [joinColumn.name]: id,\n                ...(joinTable.on || {}),\n              })\n              .transacting(trx)\n              .execute();\n\n            const rows = (cleanRelationData.set ?? []).map((data, idx) => ({\n              [joinColumn.name]: id,\n              [idColumn.name]: data.id,\n              [typeColumn.name]: data[typeField],\n              field: attributeName,\n              ...(joinTable.on || {}),\n              ...(data.__pivot || {}),\n              order: idx + 1,\n            })) satisfies Record<string, any>[];\n\n            await deleteRelatedMorphOneRelationsAfterMorphToManyUpdate(rows, {\n              uid,\n              attributeName,\n              joinTable,\n              db,\n              transaction: trx,\n            });\n\n            await this.createQueryBuilder(joinTable.name).insert(rows).transacting(trx).execute();\n          }\n\n          continue;\n        }\n\n        if ('joinColumn' in attribute && attribute.joinColumn && attribute.owner) {\n          // handled in the row itself\n          continue;\n        }\n\n        // oneToOne oneToMany on the non owning side.\n        // Since it is a join column no need to remove previous relations\n        if ('joinColumn' in attribute && attribute.joinColumn && !attribute.owner) {\n          // need to set the column on the target\n          const { target } = attribute;\n\n          await this.createQueryBuilder(target)\n            .where({ [attribute.joinColumn.referencedColumn]: id })\n            .update({ [attribute.joinColumn.referencedColumn]: null })\n            .transacting(trx)\n            .execute();\n\n          if (!isNull(cleanRelationData.set)) {\n            const relIdsToAdd = toIds(cleanRelationData.set);\n            await this.createQueryBuilder(target)\n              .where({ id: relIdsToAdd })\n              .update({ [attribute.joinColumn.referencedColumn]: id })\n              .transacting(trx)\n              .execute();\n          }\n        }\n\n        if (attribute.joinTable) {\n          const { joinTable } = attribute;\n          const { joinColumn, inverseJoinColumn, orderColumnName, inverseOrderColumnName } =\n            joinTable;\n          const select = [joinColumn.name, inverseJoinColumn.name];\n          if (hasOrderColumn(attribute)) {\n            select.push(orderColumnName);\n          }\n          if (hasInverseOrderColumn(attribute)) {\n            select.push(inverseOrderColumnName);\n          }\n\n          // only delete relations\n          if (isNull(cleanRelationData.set)) {\n            await deleteRelations({ id, attribute, db, relIdsToDelete: 'all', transaction: trx });\n          } else {\n            const isPartialUpdate = !has('set', cleanRelationData);\n            let relIdsToaddOrMove: ID[];\n\n            if (isPartialUpdate) {\n              if (isAnyToOne(attribute)) {\n                // TODO: V5 find a fix to connect multiple versions of a document at the same time on xToOne relations\n                // cleanRelationData.connect = cleanRelationData.connect?.slice(-1);\n              }\n              relIdsToaddOrMove = toIds(cleanRelationData.connect);\n              const relIdsToDelete = toIds(\n                differenceWith(\n                  isEqual,\n                  cleanRelationData.disconnect,\n                  cleanRelationData.connect ?? []\n                )\n              );\n\n              if (!isEmpty(relIdsToDelete)) {\n                await deleteRelations({ id, attribute, db, relIdsToDelete, transaction: trx });\n              }\n\n              if (isEmpty(cleanRelationData.connect)) {\n                continue;\n              }\n\n              // Fetch current relations to handle ordering\n              let currentMovingRels: Record<string, ID>[] = [];\n\n              if (hasOrderColumn(attribute) || hasInverseOrderColumn(attribute)) {\n                currentMovingRels = await this.createQueryBuilder(joinTable.name)\n                  .select(select)\n                  .where({\n                    [joinColumn.name]: id,\n                    [inverseJoinColumn.name]: { $in: relIdsToaddOrMove },\n                  })\n                  .where(joinTable.on || {})\n                  .transacting(trx)\n                  .execute();\n              }\n\n              // prepare relations to insert\n              const insert = uniqBy('id', cleanRelationData.connect).map((relToAdd) => ({\n                [joinColumn.name]: id,\n                [inverseJoinColumn.name]: relToAdd.id,\n                ...(joinTable.on || {}),\n                ...(relToAdd.__pivot || {}),\n              }));\n\n              if (hasOrderColumn(attribute)) {\n                // Get all adjacent relations and the one with the highest order\n                const adjacentRelations = await this.createQueryBuilder(joinTable.name)\n                  .where({\n                    $or: [\n                      {\n                        [joinColumn.name]: id,\n                        [inverseJoinColumn.name]: {\n                          $in: compact(\n                            cleanRelationData.connect?.map(\n                              (r) => r.position?.after || r.position?.before\n                            )\n                          ),\n                        },\n                      },\n                      {\n                        [joinColumn.name]: id,\n                        [orderColumnName]: this.createQueryBuilder(joinTable.name)\n                          .max(orderColumnName)\n                          .where({ [joinColumn.name]: id })\n                          .where(joinTable.on || {})\n                          .transacting(trx)\n                          .getKnexQuery(),\n                      },\n                    ],\n                  })\n                  .where(joinTable.on || {})\n                  .transacting(trx)\n                  .execute<Array<Record<string, any>>>();\n\n                const orderMap = relationsOrderer(\n                  adjacentRelations,\n                  inverseJoinColumn.name,\n                  joinTable.orderColumnName,\n                  cleanRelationData.options?.strict\n                )\n                  .connect(cleanRelationData.connect ?? [])\n                  .getOrderMap();\n\n                insert.forEach((row) => {\n                  row[orderColumnName] = orderMap[row[inverseJoinColumn.name]];\n                });\n              }\n\n              // add inv order value\n              if (hasInverseOrderColumn(attribute)) {\n                const nonExistingRelsIds: ID[] = difference(\n                  relIdsToaddOrMove,\n                  map(inverseJoinColumn.name, currentMovingRels)\n                );\n\n                const maxResults = await db\n                  .getConnection()\n                  .select(inverseJoinColumn.name)\n                  .max(inverseOrderColumnName, { as: 'max' })\n                  .whereIn(inverseJoinColumn.name, nonExistingRelsIds)\n                  .where(joinTable.on || {})\n                  .groupBy(inverseJoinColumn.name)\n                  .from(joinTable.name)\n                  .transacting(trx);\n\n                const maxMap = maxResults.reduce(\n                  (acc, res) => Object.assign(acc, { [res[inverseJoinColumn.name]]: res.max }),\n                  {}\n                );\n\n                insert.forEach((row) => {\n                  row[inverseOrderColumnName] = (maxMap[row[inverseJoinColumn.name]] || 0) + 1;\n                });\n              }\n\n              // insert rows\n              const query = this.createQueryBuilder(joinTable.name)\n                .insert(insert)\n                .onConflict(joinTable.pivotColumns)\n                .transacting(trx);\n\n              if (hasOrderColumn(attribute)) {\n                query.merge([orderColumnName]);\n              } else {\n                query.ignore();\n              }\n\n              await query.execute();\n\n              // remove gap between orders\n              await cleanOrderColumns({ attribute, db, id, transaction: trx });\n            } else {\n              if (isAnyToOne(attribute)) {\n                cleanRelationData.set = cleanRelationData.set?.slice(-1);\n              }\n              // overwrite all relations\n              relIdsToaddOrMove = toIds(cleanRelationData.set);\n              await deleteRelations({\n                id,\n                attribute,\n                db,\n                relIdsToDelete: 'all',\n                relIdsToNotDelete: relIdsToaddOrMove,\n                transaction: trx,\n              });\n\n              if (isEmpty(cleanRelationData.set)) {\n                continue;\n              }\n\n              const insert = uniqBy('id', cleanRelationData.set).map((relToAdd) => ({\n                [joinColumn.name]: id,\n                [inverseJoinColumn.name]: relToAdd.id,\n                ...(joinTable.on || {}),\n                ...(relToAdd.__pivot || {}),\n              }));\n\n              // add order value\n              if (hasOrderColumn(attribute)) {\n                insert.forEach((row, idx) => {\n                  row[orderColumnName] = idx + 1;\n                });\n              }\n\n              // add inv order value\n              if (hasInverseOrderColumn(attribute)) {\n                const existingRels = await this.createQueryBuilder(joinTable.name)\n                  .select(inverseJoinColumn.name)\n                  .where({\n                    [joinColumn.name]: id,\n                    [inverseJoinColumn.name]: { $in: relIdsToaddOrMove },\n                  })\n                  .where(joinTable.on || {})\n                  .transacting(trx)\n                  .execute<Array<Record<string, ID>>>();\n\n                const inverseRelsIds = map(inverseJoinColumn.name, existingRels);\n\n                const nonExistingRelsIds = difference(relIdsToaddOrMove, inverseRelsIds);\n\n                const maxResults = await db\n                  .getConnection()\n                  .select(inverseJoinColumn.name)\n                  .max(inverseOrderColumnName, { as: 'max' })\n                  .whereIn(inverseJoinColumn.name, nonExistingRelsIds)\n                  .where(joinTable.on || {})\n                  .groupBy(inverseJoinColumn.name)\n                  .from(joinTable.name)\n                  .transacting(trx);\n\n                const maxMap = maxResults.reduce(\n                  (acc, res) => Object.assign(acc, { [res[inverseJoinColumn.name]]: res.max }),\n                  {}\n                );\n\n                insert.forEach((row: any) => {\n                  row[inverseOrderColumnName] = (maxMap[row[inverseJoinColumn.name]] || 0) + 1;\n                });\n              }\n\n              // insert rows\n              const query = this.createQueryBuilder(joinTable.name)\n                .insert(insert)\n                .onConflict(joinTable.pivotColumns)\n                .transacting(trx);\n\n              if (hasOrderColumn(attribute)) {\n                query.merge([orderColumnName]);\n              } else {\n                query.ignore();\n              }\n\n              await query.execute();\n            }\n\n            // Delete the previous relations for oneToAny relations\n            if (isBidirectional(attribute) && isOneToAny(attribute)) {\n              await deletePreviousOneToAnyRelations({\n                id,\n                attribute,\n                relIdsToadd: relIdsToaddOrMove,\n                db,\n                transaction: trx,\n              });\n            }\n\n            // Delete the previous relations for anyToOne relations\n            if (isAnyToOne(attribute)) {\n              await deletePreviousAnyToOneRelations({\n                id,\n                attribute,\n                relIdToadd: relIdsToaddOrMove[0],\n                db,\n                transaction: trx,\n              });\n            }\n          }\n        }\n      }\n    },\n\n    /**\n     * Delete relational associations of an existing entity\n     * This removes associations but doesn't do cascade deletions for components for example. This will be handled on the entity service layer instead\n     * NOTE: Most of the deletion should be handled by ON DELETE CASCADE for dialects that have FKs\n     *\n     * @param {EntityManager} em - entity manager instance\n     * @param {Metadata} metadata - model metadta\n     * @param {ID} id - entity ID\n     */\n    async deleteRelations(uid, id, options) {\n      const { attributes } = db.metadata.get(uid);\n      const { transaction: trx } = options ?? {};\n\n      for (const attributeName of Object.keys(attributes)) {\n        const attribute = attributes[attributeName];\n\n        if (attribute.type !== 'relation') {\n          continue;\n        }\n\n        /*\n          if morphOne | morphMany\n            if morphBy is morphToOne\n              set null\n            if morphBy is morphToOne\n              delete links\n        */\n        if (attribute.relation === 'morphOne' || attribute.relation === 'morphMany') {\n          const { target, morphBy } = attribute;\n\n          const targetAttribute = db.metadata.get(target).attributes[morphBy];\n\n          if (targetAttribute.type === 'relation' && targetAttribute.relation === 'morphToOne') {\n            // set columns\n            const { idColumn, typeColumn } = targetAttribute.morphColumn;\n\n            await this.createQueryBuilder(target)\n              .update({ [idColumn.name]: null, [typeColumn.name]: null })\n              .where({ [idColumn.name]: id, [typeColumn.name]: uid })\n              .transacting(trx)\n              .execute();\n          } else if (\n            targetAttribute.type === 'relation' &&\n            targetAttribute.relation === 'morphToMany'\n          ) {\n            const { joinTable } = targetAttribute;\n            const { morphColumn } = joinTable;\n\n            const { idColumn, typeColumn } = morphColumn;\n\n            await this.createQueryBuilder(joinTable.name)\n              .delete()\n              .where({\n                [idColumn.name]: id,\n                [typeColumn.name]: uid,\n                ...(joinTable.on || {}),\n                field: attributeName,\n              })\n              .transacting(trx)\n              .execute();\n          }\n\n          continue;\n        }\n\n        /*\n          if morphToOne\n            nothing to do\n        */\n        if (attribute.relation === 'morphToOne') {\n          //