import {
  COLLECTION_TYPES,
  PUBLISHED_AT_ATTRIBUTE_NAME,
  SINGLE_TYPES,
  buildValidParams,
  capitalise,
  isBaseQueryError,
  useAutoCloneDocumentMutation,
  useCloneDocumentMutation,
  useCreateDocumentMutation,
  useDeleteDocumentMutation,
  useDeleteManyDocumentsMutation,
  useDiscardDocumentMutation,
  useDoc,
  useDocument,
  useLazyGetDocumentQuery,
  useLazyGetDraftRelationCountQuery,
  usePublishDocumentMutation,
  usePublishManyDocumentsMutation,
  useUnpublishDocumentMutation,
  useUnpublishManyDocumentsMutation,
  useUpdateDocumentMutation
} from "./chunk-JIFANRG6.js";
import {
  getTranslation
} from "./chunk-HIZVCZYI.js";
import {
  useGuidedTour
} from "./chunk-IJBKCR3K.js";
import {
  useTracking
} from "./chunk-AWEPTK4E.js";
import {
  require_mapValues
} from "./chunk-L7CKIK7M.js";
import {
  useForm
} from "./chunk-W2EBIS6P.js";
import {
  useRBAC
} from "./chunk-2YJPP6F5.js";
import {
  Page,
  useAPIErrorHandler
} from "./chunk-LQ66U5BX.js";
import {
  useAuth,
  useQueryParams
} from "./chunk-7IDP7SCX.js";
import {
  createContext
} from "./chunk-2W3NWVKQ.js";
import {
  useNotification
} from "./chunk-GSOKMUI2.js";
import {
  require_convert,
  require_placeholder
} from "./chunk-MV7EAZLN.js";
import {
  Button,
  Dialog,
  Flex,
  Menu,
  Modal,
  Radio,
  Status,
  Typography,
  VisuallyHidden,
  useIntl
} from "./chunk-GEQAKZDT.js";
import {
  Navigate,
  useMatch,
  useNavigate,
  useParams
} from "./chunk-TUXTO2Z5.js";
import {
  ForwardRef$1V,
  ForwardRef$3,
  ForwardRef$45
} from "./chunk-QXF2FKMZ.js";
import {
  require_jsx_runtime
} from "./chunk-NIAJZ5MX.js";
import {
  dt
} from "./chunk-6EUTJK7T.js";
import {
  require_react
} from "./chunk-MADUDGYZ.js";
import {
  __commonJS,
  __toESM
} from "./chunk-PLDDJCW6.js";

// node_modules/lodash/fp/mapValues.js
var require_mapValues2 = __commonJS({
  "node_modules/lodash/fp/mapValues.js"(exports, module) {
    var convert = require_convert();
    var func = convert("mapValues", require_mapValues());
    func.placeholder = require_placeholder();
    module.exports = func;
  }
});

// node_modules/@strapi/content-manager/dist/admin/constants/plugin.mjs
var PLUGIN_ID = "content-manager";
var PERMISSIONS = [
  "plugin::content-manager.explorer.create",
  "plugin::content-manager.explorer.read",
  "plugin::content-manager.explorer.update",
  "plugin::content-manager.explorer.delete",
  "plugin::content-manager.explorer.publish"
];

// node_modules/@strapi/content-manager/dist/admin/features/DocumentContext.mjs
var import_jsx_runtime = __toESM(require_jsx_runtime(), 1);
var React = __toESM(require_react(), 1);
var [DocumentProvider, useDocumentContext] = createContext("DocumentContext");
var DocumentContextProvider = ({ children, initialDocument, onPreview }) => {
  const [currentDocumentMeta, changeDocument] = React.useState(initialDocument);
  const params = React.useMemo(() => buildValidParams(currentDocumentMeta.params ?? {}), [
    currentDocumentMeta.params
  ]);
  const document = useDocument({
    ...currentDocumentMeta,
    params
  });
  const [documentHistory, setDocumentHistory] = React.useState([]);
  return (0, import_jsx_runtime.jsx)(DocumentProvider, {
    changeDocument,
    document,
    rootDocumentMeta: {
      documentId: initialDocument.documentId,
      model: initialDocument.model,
      collectionType: initialDocument.collectionType
    },
    meta: currentDocumentMeta,
    documentHistory,
    setDocumentHistory,
    onPreview,
    children
  });
};

// node_modules/@strapi/content-manager/dist/admin/features/DocumentRBAC.mjs
var import_jsx_runtime2 = __toESM(require_jsx_runtime(), 1);
var React2 = __toESM(require_react(), 1);
var [DocumentRBACProvider, useDocumentRBAC] = createContext("DocumentRBAC", {
  canCreate: false,
  canCreateFields: [],
  canDelete: false,
  canPublish: false,
  canRead: false,
  canReadFields: [],
  canUpdate: false,
  canUpdateFields: [],
  canUserAction: () => false,
  isLoading: false
});
var DocumentRBAC = ({ children, permissions, model }) => {
  const { slug } = useParams();
  if (!slug && !model) {
    throw new Error("Cannot find the slug param in the URL or the model prop is not provided.");
  }
  const contentTypeUid = model ?? slug;
  const [{ rawQuery }] = useQueryParams();
  const userPermissions = useAuth("DocumentRBAC", (state) => state.permissions);
  const contentTypePermissions = React2.useMemo(() => {
    const contentTypePermissions2 = userPermissions.filter((permission) => permission.subject === contentTypeUid);
    return contentTypePermissions2.reduce((acc, permission) => {
      const [action] = permission.action.split(".").slice(-1);
      return {
        ...acc,
        [action]: [
          permission
        ]
      };
    }, {});
  }, [
    contentTypeUid,
    userPermissions
  ]);
  const { isLoading, allowedActions } = useRBAC(
    contentTypePermissions,
    permissions ?? void 0,
    // TODO: useRBAC context should be typed and built differently
    // We are passing raw query as context to the hook so that it can
    // rely on the locale provided from DocumentRBAC for its permission calculations.
    rawQuery
  );
  const canCreateFields = !isLoading && allowedActions.canCreate ? extractAndDedupeFields(contentTypePermissions.create) : [];
  const canReadFields = !isLoading && allowedActions.canRead ? extractAndDedupeFields(contentTypePermissions.read) : [];
  const canUpdateFields = !isLoading && allowedActions.canUpdate ? extractAndDedupeFields(contentTypePermissions.update) : [];
  const canUserAction = React2.useCallback((fieldName, fieldsUserCanAction, fieldType) => {
    const name = removeNumericalStrings(fieldName.split("."));
    const componentFieldNames = fieldsUserCanAction.filter((field) => field.split(".").length > 1);
    if (fieldType === "component") {
      return componentFieldNames.some((field) => {
        return field.includes(name.join("."));
      });
    }
    if (name.length > 1) {
      return componentFieldNames.includes(name.join("."));
    }
    return fieldsUserCanAction.includes(fieldName);
  }, []);
  if (isLoading) {
    return (0, import_jsx_runtime2.jsx)(Page.Loading, {});
  }
  return (0, import_jsx_runtime2.jsx)(DocumentRBACProvider, {
    isLoading,
    canCreateFields,
    canReadFields,
    canUpdateFields,
    canUserAction,
    ...allowedActions,
    children
  });
};
var extractAndDedupeFields = (permissions = []) => permissions.flatMap((permission) => {
  var _a;
  return (_a = permission.properties) == null ? void 0 : _a.fields;
}).filter((field, index, arr) => arr.indexOf(field) === index && typeof field === "string");
var removeNumericalStrings = (arr) => arr.filter((item) => isNaN(Number(item)));

// node_modules/@strapi/content-manager/dist/admin/hooks/useDocumentActions.mjs
var React3 = __toESM(require_react(), 1);
var DEFAULT_UNEXPECTED_ERROR_MSG = {
  id: "notification.error",
  defaultMessage: "An error occurred, please try again"
};
var useDocumentActions = (fromPreview = false, fromRelationModal = false) => {
  const { toggleNotification } = useNotification();
  const { formatMessage } = useIntl();
  const { trackUsage } = useTracking();
  const { _unstableFormatAPIError: formatAPIError } = useAPIErrorHandler();
  const navigate = useNavigate();
  const setCurrentStep = useGuidedTour("useDocumentActions", (state) => state.setCurrentStep);
  const [deleteDocument, { isLoading: isDeleting }] = useDeleteDocumentMutation();
  const _delete = React3.useCallback(async ({ collectionType, model, documentId, params }, trackerProperty) => {
    try {
      trackUsage("willDeleteEntry", trackerProperty);
      const res = await deleteDocument({
        collectionType,
        model,
        documentId,
        params
      });
      if ("error" in res) {
        toggleNotification({
          type: "danger",
          message: formatAPIError(res.error)
        });
        return {
          error: res.error
        };
      }
      toggleNotification({
        type: "success",
        message: formatMessage({
          id: getTranslation("success.record.delete"),
          defaultMessage: "Deleted document"
        })
      });
      trackUsage("didDeleteEntry", trackerProperty);
      return res.data;
    } catch (err) {
      toggleNotification({
        type: "danger",
        message: formatMessage(DEFAULT_UNEXPECTED_ERROR_MSG)
      });
      trackUsage("didNotDeleteEntry", {
        error: err,
        ...trackerProperty
      });
      throw err;
    }
  }, [
    trackUsage,
    deleteDocument,
    toggleNotification,
    formatMessage,
    formatAPIError
  ]);
  const [deleteManyDocuments, { isLoading: isDeletingMany }] = useDeleteManyDocumentsMutation();
  const deleteMany = React3.useCallback(async ({ model, documentIds, params }) => {
    try {
      trackUsage("willBulkDeleteEntries");
      const res = await deleteManyDocuments({
        model,
        documentIds,
        params
      });
      if ("error" in res) {
        toggleNotification({
          type: "danger",
          message: formatAPIError(res.error)
        });
        return {
          error: res.error
        };
      }
      toggleNotification({
        type: "success",
        title: formatMessage({
          id: getTranslation("success.records.delete"),
          defaultMessage: "Successfully deleted."
        }),
        message: ""
      });
      trackUsage("didBulkDeleteEntries");
      return res.data;
    } catch (err) {
      toggleNotification({
        type: "danger",
        message: formatMessage(DEFAULT_UNEXPECTED_ERROR_MSG)
      });
      trackUsage("didNotBulkDeleteEntries");
      throw err;
    }
  }, [
    trackUsage,
    deleteManyDocuments,
    toggleNotification,
    formatMessage,
    formatAPIError
  ]);
  const [discardDocument, { isLoading: isDiscardingDocument }] = useDiscardDocumentMutation();
  const discard = React3.useCallback(async ({ collectionType, model, documentId, params }) => {
    try {
      const res = await discardDocument({
        collectionType,
        model,
        documentId,
        params
      });
      if ("error" in res) {
        toggleNotification({
          type: "danger",
          message: formatAPIError(res.error)
        });
        return {
          error: res.error
        };
      }
      toggleNotification({
        type: "success",
        message: formatMessage({
          id: "content-manager.success.record.discard",
          defaultMessage: "Changes discarded"
        })
      });
      return res.data;
    } catch (err) {
      toggleNotification({
        type: "danger",
        message: formatMessage(DEFAULT_UNEXPECTED_ERROR_MSG)
      });
      throw err;
    }
  }, [
    discardDocument,
    formatAPIError,
    formatMessage,
    toggleNotification
  ]);
  const [publishDocument, { isLoading: isPublishing }] = usePublishDocumentMutation();
  const publish = React3.useCallback(async ({ collectionType, model, documentId, params }, data) => {
    try {
      trackUsage("willPublishEntry", {
        documentId
      });
      const res = await publishDocument({
        collectionType,
        model,
        documentId,
        data,
        params
      });
      if ("error" in res) {
        toggleNotification({
          type: "danger",
          message: formatAPIError(res.error)
        });
        return {
          error: res.error
        };
      }
      trackUsage("didPublishEntry", {
        documentId,
        fromPreview,
        fromRelationModal
      });
      toggleNotification({
        type: "success",
        message: formatMessage({
          id: getTranslation("success.record.publish"),
          defaultMessage: "Published document"
        })
      });
      return res.data;
    } catch (err) {
      toggleNotification({
        type: "danger",
        message: formatMessage(DEFAULT_UNEXPECTED_ERROR_MSG)
      });
      throw err;
    }
  }, [
    trackUsage,
    publishDocument,
    fromPreview,
    fromRelationModal,
    toggleNotification,
    formatMessage,
    formatAPIError
  ]);
  const [publishManyDocuments, { isLoading: isPublishingMany }] = usePublishManyDocumentsMutation();
  const publishMany = React3.useCallback(async ({ model, documentIds, params }) => {
    try {
      const res = await publishManyDocuments({
        model,
        documentIds,
        params
      });
      if ("error" in res) {
        toggleNotification({
          type: "danger",
          message: formatAPIError(res.error)
        });
        return {
          error: res.error
        };
      }
      toggleNotification({
        type: "success",
        message: formatMessage({
          id: getTranslation("success.record.publish"),
          defaultMessage: "Published document"
        })
      });
      return res.data;
    } catch (err) {
      toggleNotification({
        type: "danger",
        message: formatMessage(DEFAULT_UNEXPECTED_ERROR_MSG)
      });
      throw err;
    }
  }, [
    // trackUsage,
    publishManyDocuments,
    toggleNotification,
    formatMessage,
    formatAPIError
  ]);
  const [updateDocument, { isLoading: isUpdating }] = useUpdateDocumentMutation();
  const update = React3.useCallback(async ({ collectionType, model, documentId, params }, data, trackerProperty) => {
    try {
      trackUsage("willEditEntry", trackerProperty);
      const res = await updateDocument({
        collectionType,
        model,
        documentId,
        data,
        params
      });
      if ("error" in res) {
        toggleNotification({
          type: "danger",
          message: formatAPIError(res.error)
        });
        trackUsage("didNotEditEntry", {
          error: res.error,
          ...trackerProperty
        });
        return {
          error: res.error
        };
      }
      trackUsage("didEditEntry", {
        ...trackerProperty,
        documentId: res.data.data.documentId,
        fromPreview,
        fromRelationModal
      });
      toggleNotification({
        type: "success",
        message: formatMessage({
          id: getTranslation("success.record.save"),
          defaultMessage: "Saved document"
        })
      });
      return res.data;
    } catch (err) {
      trackUsage("didNotEditEntry", {
        error: err,
        ...trackerProperty
      });
      toggleNotification({
        type: "danger",
        message: formatMessage(DEFAULT_UNEXPECTED_ERROR_MSG)
      });
      throw err;
    }
  }, [
    trackUsage,
    updateDocument,
    fromPreview,
    fromRelationModal,
    toggleNotification,
    formatMessage,
    formatAPIError
  ]);
  const [unpublishDocument] = useUnpublishDocumentMutation();
  const unpublish = React3.useCallback(async ({ collectionType, model, documentId, params }, discardDraft = false) => {
    try {
      trackUsage("willUnpublishEntry");
      const res = await unpublishDocument({
        collectionType,
        model,
        documentId,
        params,
        data: {
          discardDraft
        }
      });
      if ("error" in res) {
        toggleNotification({
          type: "danger",
          message: formatAPIError(res.error)
        });
        return {
          error: res.error
        };
      }
      trackUsage("didUnpublishEntry");
      toggleNotification({
        type: "success",
        message: formatMessage({
          id: getTranslation("success.record.unpublish"),
          defaultMessage: "Unpublished document"
        })
      });
      return res.data;
    } catch (err) {
      toggleNotification({
        type: "danger",
        message: formatMessage(DEFAULT_UNEXPECTED_ERROR_MSG)
      });
      throw err;
    }
  }, [
    trackUsage,
    unpublishDocument,
    toggleNotification,
    formatMessage,
    formatAPIError
  ]);
  const [unpublishManyDocuments, { isLoading: isUnpublishingMany }] = useUnpublishManyDocumentsMutation();
  const unpublishMany = React3.useCallback(async ({ model, documentIds, params }) => {
    try {
      trackUsage("willBulkUnpublishEntries");
      const res = await unpublishManyDocuments({
        model,
        documentIds,
        params
      });
      if ("error" in res) {
        toggleNotification({
          type: "danger",
          message: formatAPIError(res.error)
        });
        return {
          error: res.error
        };
      }
      trackUsage("didBulkUnpublishEntries");
      toggleNotification({
        type: "success",
        title: formatMessage({
          id: getTranslation("success.records.unpublish"),
          defaultMessage: "Successfully unpublished."
        }),
        message: ""
      });
      return res.data;
    } catch (err) {
      toggleNotification({
        type: "danger",
        message: formatMessage(DEFAULT_UNEXPECTED_ERROR_MSG)
      });
      trackUsage("didNotBulkUnpublishEntries");
      throw err;
    }
  }, [
    trackUsage,
    unpublishManyDocuments,
    toggleNotification,
    formatMessage,
    formatAPIError
  ]);
  const [createDocument] = useCreateDocumentMutation();
  const create = React3.useCallback(async ({ model, params }, data, trackerProperty) => {
    try {
      const res = await createDocument({
        model,
        data,
        params
      });
      if ("error" in res) {
        toggleNotification({
          type: "danger",
          message: formatAPIError(res.error)
        });
        trackUsage("didNotCreateEntry", {
          error: res.error,
          ...trackerProperty
        });
        return {
          error: res.error
        };
      }
      trackUsage("didCreateEntry", {
        ...trackerProperty,
        documentId: res.data.data.documentId
      });
      toggleNotification({
        type: "success",
        message: formatMessage({
          id: getTranslation("success.record.save"),
          defaultMessage: "Saved document"
        })
      });
      setCurrentStep("contentManager.success");
      return res.data;
    } catch (err) {
      toggleNotification({
        type: "danger",
        message: formatMessage(DEFAULT_UNEXPECTED_ERROR_MSG)
      });
      trackUsage("didNotCreateEntry", {
        error: err,
        ...trackerProperty
      });
      throw err;
    }
  }, [
    createDocument,
    formatAPIError,
    formatMessage,
    setCurrentStep,
    toggleNotification,
    trackUsage
  ]);
  const [autoCloneDocument] = useAutoCloneDocumentMutation();
  const autoClone = React3.useCallback(async ({ model, sourceId }) => {
    try {
      const res = await autoCloneDocument({
        model,
        sourceId
      });
      if ("error" in res) {
        return {
          error: res.error
        };
      }
      toggleNotification({
        type: "success",
        message: formatMessage({
          id: getTranslation("success.record.clone"),
          defaultMessage: "Cloned document"
        })
      });
      return res.data;
    } catch (err) {
      toggleNotification({
        type: "danger",
        message: formatMessage(DEFAULT_UNEXPECTED_ERROR_MSG)
      });
      throw err;
    }
  }, [
    autoCloneDocument,
    formatMessage,
    toggleNotification
  ]);
  const [cloneDocument] = useCloneDocumentMutation();
  const clone = React3.useCallback(async ({ model, documentId, params }, body, trackerProperty) => {
    try {
      const { id: _id, ...restBody } = body;
      const res = await cloneDocument({
        model,
        sourceId: documentId,
        data: restBody,
        params
      });
      if ("error" in res) {
        toggleNotification({
          type: "danger",
          message: formatAPIError(res.error)
        });
        trackUsage("didNotCreateEntry", {
          error: res.error,
          ...trackerProperty
        });
        return {
          error: res.error
        };
      }
      trackUsage("didCreateEntry", trackerProperty);
      toggleNotification({
        type: "success",
        message: formatMessage({
          id: getTranslation("success.record.clone"),
          defaultMessage: "Cloned document"
        })
      });
      navigate(`../../${res.data.data.documentId}`, {
        relative: "path"
      });
      return res.data;
    } catch (err) {
      toggleNotification({
        type: "danger",
        message: formatMessage(DEFAULT_UNEXPECTED_ERROR_MSG)
      });
      trackUsage("didNotCreateEntry", {
        error: err,
        ...trackerProperty
      });
      throw err;
    }
  }, [
    cloneDocument,
    trackUsage,
    toggleNotification,
    formatMessage,
    formatAPIError,
    navigate
  ]);
  const [getDoc] = useLazyGetDocumentQuery();
  const getDocument = React3.useCallback(async (args) => {
    const { data } = await getDoc(args);
    return data;
  }, [
    getDoc
  ]);
  return {
    isLoading: isPublishing || isUpdating || isDiscardingDocument || isDeleting || isDeletingMany || isUnpublishingMany || isPublishingMany,
    autoClone,
    clone,
    create,
    delete: _delete,
    deleteMany,
    discard,
    getDocument,
    publish,
    publishMany,
    unpublish,
    unpublishMany,
    update
  };
};

// node_modules/@strapi/content-manager/dist/admin/pages/EditView/components/DocumentStatus.mjs
var import_jsx_runtime3 = __toESM(require_jsx_runtime(), 1);
var DocumentStatus = ({ status = "draft", size = "S", ...restProps }) => {
  const statusVariant = status === "draft" ? "secondary" : status === "published" ? "success" : "alternative";
  const { formatMessage } = useIntl();
  return (0, import_jsx_runtime3.jsx)(Status, {
    ...restProps,
    size,
    variant: statusVariant,
    role: "status",
    "aria-label": status,
    children: (0, import_jsx_runtime3.jsx)(Typography, {
      tag: "span",
      variant: "omega",
      fontWeight: "bold",
      children: formatMessage({
        id: `content-manager.containers.List.${status}`,
        defaultMessage: capitalise(status)
      })
    })
  });
};

// node_modules/@strapi/content-manager/dist/admin/router.mjs
var import_jsx_runtime4 = __toESM(require_jsx_runtime(), 1);
var import_react = __toESM(require_react(), 1);

// node_modules/@strapi/content-manager/dist/admin/history/routes.mjs
var React4 = __toESM(require_react(), 1);
var ProtectedHistoryPage = React4.lazy(() => import("./History-IUHV2RK3.js").then((mod) => ({
  default: mod.ProtectedHistoryPage
})));
var routes = [
  {
    path: ":collectionType/:slug/:id/history",
    Component: ProtectedHistoryPage
  },
  {
    path: ":collectionType/:slug/history",
    Component: ProtectedHistoryPage
  }
];

// node_modules/@strapi/content-manager/dist/admin/preview/routes.mjs
var React5 = __toESM(require_react(), 1);
var ProtectedPreviewPage = React5.lazy(() => import("./Preview-4EXCQ43M.js").then((mod) => ({
  default: mod.ProtectedPreviewPage
})));
var routes2 = [
  {
    path: ":collectionType/:slug/:id/preview",
    Component: ProtectedPreviewPage
  },
  {
    path: ":collectionType/:slug/preview",
    Component: ProtectedPreviewPage
  }
];

// node_modules/@strapi/content-manager/dist/admin/router.mjs
var ProtectedEditViewPage = (0, import_react.lazy)(() => import("./EditViewPage-HULMK67G.js").then((mod) => ({
  default: mod.ProtectedEditViewPage
})));
var ProtectedListViewPage = (0, import_react.lazy)(() => import("./ListViewPage-GNTA2GV6.js").then((mod) => ({
  default: mod.ProtectedListViewPage
})));
var ProtectedListConfiguration = (0, import_react.lazy)(() => import("./ListConfigurationPage-Q3GHCADY.js").then((mod) => ({
  default: mod.ProtectedListConfiguration
})));
var ProtectedEditConfigurationPage = (0, import_react.lazy)(() => import("./EditConfigurationPage-42LLJEQG.js").then((mod) => ({
  default: mod.ProtectedEditConfigurationPage
})));
var ProtectedComponentConfigurationPage = (0, import_react.lazy)(() => import("./ComponentConfigurationPage-BZLG2N7M.js").then((mod) => ({
  default: mod.ProtectedComponentConfigurationPage
})));
var NoPermissions = (0, import_react.lazy)(() => import("./NoPermissionsPage-ER45ZG6O.js").then((mod) => ({
  default: mod.NoPermissions
})));
var NoContentType = (0, import_react.lazy)(() => import("./NoContentTypePage-BY6NWVX3.js").then((mod) => ({
  default: mod.NoContentType
})));
var CollectionTypePages = () => {
  const { collectionType } = useParams();
  if (collectionType !== COLLECTION_TYPES && collectionType !== SINGLE_TYPES) {
    return (0, import_jsx_runtime4.jsx)(Navigate, {
      to: "/404"
    });
  }
  return collectionType === COLLECTION_TYPES ? (0, import_jsx_runtime4.jsx)(ProtectedListViewPage, {}) : (0, import_jsx_runtime4.jsx)(ProtectedEditViewPage, {});
};
var CLONE_RELATIVE_PATH = ":collectionType/:slug/clone/:origin";
var CLONE_PATH = `/content-manager/${CLONE_RELATIVE_PATH}`;
var LIST_RELATIVE_PATH = ":collectionType/:slug";
var LIST_PATH = `/content-manager/collection-types/:slug`;
var routes3 = [
  {
    path: LIST_RELATIVE_PATH,
    element: (0, import_jsx_runtime4.jsx)(CollectionTypePages, {})
  },
  {
    path: ":collectionType/:slug/:id",
    Component: ProtectedEditViewPage
  },
  {
    path: CLONE_RELATIVE_PATH,
    Component: ProtectedEditViewPage
  },
  {
    path: ":collectionType/:slug/configurations/list",
    Component: ProtectedListConfiguration
  },
  {
    path: "components/:slug/configurations/edit",
    Component: ProtectedComponentConfigurationPage
  },
  {
    path: ":collectionType/:slug/configurations/edit",
    Component: ProtectedEditConfigurationPage
  },
  {
    path: "403",
    Component: NoPermissions
  },
  {
    path: "no-content-types",
    Component: NoContentType
  },
  ...routes,
  ...routes2
];

// node_modules/@strapi/content-manager/dist/admin/pages/EditView/components/DocumentActions.mjs
var import_jsx_runtime5 = __toESM(require_jsx_runtime(), 1);
var React6 = __toESM(require_react(), 1);
var import_mapValues = __toESM(require_mapValues2(), 1);
var DocumentActions = ({ actions }) => {
  const { formatMessage } = useIntl();
  const [primaryAction, secondaryAction, ...restActions] = actions.filter((action) => {
    if (action.position === void 0) {
      return true;
    }
    const positions = Array.isArray(action.position) ? action.position : [
      action.position
    ];
    return positions.includes("panel");
  });
  if (!primaryAction) {
    return null;
  }
  return (0, import_jsx_runtime5.jsxs)(Flex, {
    direction: "column",
    gap: 2,
    alignItems: "stretch",
    width: "100%",
    children: [
      (0, import_jsx_runtime5.jsxs)(Flex, {
        gap: 2,
        children: [
          (0, import_jsx_runtime5.jsx)(DocumentActionButton, {
            ...primaryAction,
            variant: primaryAction.variant || "default"
          }),
          restActions.length > 0 ? (0, import_jsx_runtime5.jsx)(DocumentActionsMenu, {
            actions: restActions,
            label: formatMessage({
              id: "content-manager.containers.edit.panels.default.more-actions",
              defaultMessage: "More document actions"
            })
          }) : null
        ]
      }),
      secondaryAction ? (0, import_jsx_runtime5.jsx)(DocumentActionButton, {
        ...secondaryAction,
        variant: secondaryAction.variant || "secondary"
      }) : null
    ]
  });
};
var DocumentActionButton = (action) => {
  var _a, _b, _c;
  const [dialogId, setDialogId] = React6.useState(null);
  const { toggleNotification } = useNotification();
  const handleClick = (action2) => async (e) => {
    const { onClick = () => false, dialog, id } = action2;
    const muteDialog = await onClick(e);
    if (dialog && !muteDialog) {
      switch (dialog.type) {
        case "notification":
          toggleNotification({
            title: dialog.title,
            message: dialog.content,
            type: dialog.status,
            timeout: dialog.timeout,
            onClose: dialog.onClose
          });
          break;
        case "dialog":
        case "modal":
          e.preventDefault();
          setDialogId(id);
      }
    }
  };
  const handleClose = () => {
    setDialogId(null);
  };
  return (0, import_jsx_runtime5.jsxs)(import_jsx_runtime5.Fragment, {
    children: [
      (0, import_jsx_runtime5.jsx)(Button, {
        flex: "auto",
        startIcon: action.icon,
        disabled: action.disabled,
        onClick: handleClick(action),
        justifyContent: "center",
        variant: action.variant || "default",
        paddingTop: "7px",
        paddingBottom: "7px",
        loading: action.loading,
        children: action.label
      }),
      ((_a = action.dialog) == null ? void 0 : _a.type) === "dialog" ? (0, import_jsx_runtime5.jsx)(DocumentActionConfirmDialog, {
        ...action.dialog,
        variant: ((_b = action.dialog) == null ? void 0 : _b.variant) ?? action.variant,
        isOpen: dialogId === action.id,
        onClose: handleClose
      }) : null,
      ((_c = action.dialog) == null ? void 0 : _c.type) === "modal" ? (0, import_jsx_runtime5.jsx)(DocumentActionModal, {
        ...action.dialog,
        onModalClose: handleClose,
        isOpen: dialogId === action.id
      }) : null
    ]
  });
};
var MenuItem = dt(Menu.Item)`
  &:hover {
    background: ${({ theme, isVariantDanger, isDisabled }) => isVariantDanger && !isDisabled ? theme.colors.danger100 : "neutral"};
  }
`;
var DocumentActionsMenu = ({ actions, children, label, variant = "tertiary" }) => {
  const [isOpen, setIsOpen] = React6.useState(false);
  const [dialogId, setDialogId] = React6.useState(null);
  const { formatMessage } = useIntl();
  const { toggleNotification } = useNotification();
  const isDisabled = actions.every((action) => action.disabled) || actions.length === 0;
  const handleClick = (action) => async (e) => {
    const { onClick = () => false, dialog, id } = action;
    const muteDialog = await onClick(e);
    if (dialog && !muteDialog) {
      switch (dialog.type) {
        case "notification":
          toggleNotification({
            title: dialog.title,
            message: dialog.content,
            type: dialog.status,
            timeout: dialog.timeout,
            onClose: dialog.onClose
          });
          break;
        case "dialog":
        case "modal":
          setDialogId(id);
      }
    }
  };
  const handleClose = () => {
    setDialogId(null);
    setIsOpen(false);
  };
  return (0, import_jsx_runtime5.jsxs)(Menu.Root, {
    open: isOpen,
    onOpenChange: setIsOpen,
    children: [
      (0, import_jsx_runtime5.jsxs)(Menu.Trigger, {
        disabled: isDisabled,
        size: "S",
        endIcon: null,
        paddingTop: "4px",
        paddingLeft: "7px",
        paddingRight: "7px",
        variant,
        children: [
          (0, import_jsx_runtime5.jsx)(ForwardRef$1V, {
            "aria-hidden": true,
            focusable: false
          }),
          (0, import_jsx_runtime5.jsx)(VisuallyHidden, {
            tag: "span",
            children: label || formatMessage({
              id: "content-manager.containers.edit.panels.default.more-actions",
              defaultMessage: "More document actions"
            })
          })
        ]
      }),
      (0, import_jsx_runtime5.jsxs)(Menu.Content, {
        maxHeight: void 0,
        popoverPlacement: "bottom-end",
        children: [
          actions.map((action) => {
            return (0, import_jsx_runtime5.jsx)(MenuItem, {
              disabled: action.disabled,
              /* @ts-expect-error â€“ TODO: this is an error in the DS where it is most likely a synthetic event, not regular. */
              onSelect: handleClick(action),
              display: "block",
              isVariantDanger: action.variant === "danger",
              isDisabled: action.disabled,
              children: (0, import_jsx_runtime5.jsx)(Flex, {
                justifyContent: "space-between",
                gap: 4,
                children: (0, import_jsx_runtime5.jsxs)(Flex, {
                  color: !action.disabled ? convertActionVariantToColor(action.variant) : "inherit",
                  gap: 2,
                  tag: "span",
                  children: [
                    (0, import_jsx_runtime5.jsx)(Flex, {
                      tag: "span",
                      color: !action.disabled ? convertActionVariantToIconColor(action.variant) : "inherit",
                      children: action.icon
                    }),
                    action.label
                  ]
                })
              })
            }, action.id);
          }),
          children
        ]
      }),
      actions.map((action) => {
        var _a, _b;
        return (0, import_jsx_runtime5.jsxs)(React6.Fragment, {
          children: [
            ((_a = action.dialog) == null ? void 0 : _a.type) === "dialog" ? (0, import_jsx_runtime5.jsx)(DocumentActionConfirmDialog, {
              ...action.dialog,
              variant: action.variant,
              isOpen: dialogId === action.id,
              onClose: handleClose
            }) : null,
            ((_b = action.dialog) == null ? void 0 : _b.type) === "modal" ? (0, import_jsx_runtime5.jsx)(DocumentActionModal, {
              ...action.dialog,
              onModalClose: handleClose,
              isOpen: dialogId === action.id
            }) : null
          ]
        }, action.id);
      })
    ]
  });
};
var convertActionVariantToColor = (variant = "secondary") => {
  switch (variant) {
    case "danger":
      return "danger600";
    case "secondary":
      return void 0;
    case "success":
      return "success600";
    default:
      return "primary600";
  }
};
var convertActionVariantToIconColor = (variant = "secondary") => {
  switch (variant) {
    case "danger":
      return "danger600";
    case "secondary":
      return "neutral500";
    case "success":
      return "success600";
    default:
      return "primary600";
  }
};
var DocumentActionConfirmDialog = ({ onClose, onCancel, onConfirm, title, content, isOpen, variant = "secondary", loading }) => {
  const { formatMessage } = useIntl();
  const handleClose = async () => {
    if (onCancel) {
      await onCancel();
    }
    onClose();
  };
  const handleConfirm = async () => {
    if (onConfirm) {
      await onConfirm();
    }
    onClose();
  };
  return (0, import_jsx_runtime5.jsx)(Dialog.Root, {
    open: isOpen,
    onOpenChange: handleClose,
    children: (0, import_jsx_runtime5.jsxs)(Dialog.Content, {
      children: [
        (0, import_jsx_runtime5.jsx)(Dialog.Header, {
          children: title
        }),
        (0, import_jsx_runtime5.jsx)(Dialog.Body, {
          children: content
        }),
        (0, import_jsx_runtime5.jsxs)(Dialog.Footer, {
          children: [
            (0, import_jsx_runtime5.jsx)(Dialog.Cancel, {
              children: (0, import_jsx_runtime5.jsx)(Button, {
                variant: "tertiary",
                fullWidth: true,
                children: formatMessage({
                  id: "app.components.Button.cancel",
                  defaultMessage: "Cancel"
                })
              })
            }),
            (0, import_jsx_runtime5.jsx)(Button, {
              onClick: handleConfirm,
              variant,
              fullWidth: true,
              loading,
              children: formatMessage({
                id: "app.components.Button.confirm",
                defaultMessage: "Confirm"
              })
            })
          ]
        })
      ]
    })
  });
};
var DocumentActionModal = ({ isOpen, title, onClose, footer: Footer, content: Content, onModalClose }) => {
  const handleClose = () => {
    if (onClose) {
      onClose();
    }
    onModalClose();
  };
  return (0, import_jsx_runtime5.jsx)(Modal.Root, {
    open: isOpen,
    onOpenChange: handleClose,
    children: (0, import_jsx_runtime5.jsxs)(Modal.Content, {
      children: [
        (0, import_jsx_runtime5.jsx)(Modal.Header, {
          children: (0, import_jsx_runtime5.jsx)(Modal.Title, {
            children: title
          })
        }),
        typeof Content === "function" ? (0, import_jsx_runtime5.jsx)(Content, {
          onClose: handleClose
        }) : (0, import_jsx_runtime5.jsx)(Modal.Body, {
          children: Content
        }),
        typeof Footer === "function" ? (0, import_jsx_runtime5.jsx)(Footer, {
          onClose: handleClose
        }) : Footer
      ]
    })
  });
};
var transformData = (data) => {
  if (Array.isArray(data)) {
    return data.map(transformData);
  }
  if (typeof data === "object" && data !== null) {
    if ("apiData" in data) {
      return data.apiData;
    }
    return (0, import_mapValues.default)(transformData)(data);
  }
  return data;
};
var PublishAction = ({ activeTab, documentId, model, collectionType, meta, document, onPreview, fromPreview = false, fromRelationModal = false }) => {
  var _a;
  const schema = useDocumentContext("PublishAction", (state) => state.document.schema);
  const navigate = useNavigate();
  const { toggleNotification } = useNotification();
  const { _unstableFormatValidationErrors: formatValidationErrors } = useAPIErrorHandler();
  const isListView = useMatch(LIST_PATH) !== null;
  const isCloning = useMatch(CLONE_PATH) !== null;
  const { id } = useParams();
  const { formatMessage } = useIntl();
  const canPublish = useDocumentRBAC("PublishAction", ({ canPublish: canPublish2 }) => canPublish2);
  const { publish, isLoading } = useDocumentActions(fromPreview, fromRelationModal);
  const [countDraftRelations, { isLoading: isLoadingDraftRelations, isError: isErrorDraftRelations }] = useLazyGetDraftRelationCountQuery();
  const [localCountOfDraftRelations, setLocalCountOfDraftRelations] = React6.useState(0);
  const [serverCountOfDraftRelations, setServerCountOfDraftRelations] = React6.useState(0);
  const [{ query, rawQuery }] = useQueryParams();
  const params = React6.useMemo(() => buildValidParams(query), [
    query
  ]);
  const modified = useForm("PublishAction", ({ modified: modified2 }) => modified2);
  const setSubmitting = useForm("PublishAction", ({ setSubmitting: setSubmitting2 }) => setSubmitting2);
  const isSubmitting = useForm("PublishAction", ({ isSubmitting: isSubmitting2 }) => isSubmitting2);
  const validate = useForm("PublishAction", (state) => state.validate);
  const setErrors = useForm("PublishAction", (state) => state.setErrors);
  const formValues = useForm("PublishAction", ({ values }) => values);
  const rootDocumentMeta = useDocumentContext("PublishAction", (state) => state.rootDocumentMeta);
  const currentDocumentMeta = useDocumentContext("PublishAction", (state) => state.meta);
  React6.useEffect(() => {
    if (isErrorDraftRelations) {
      toggleNotification({
        type: "danger",
        message: formatMessage({
          id: getTranslation("error.records.fetch-draft-relatons"),
          defaultMessage: "An error occurred while fetching draft relations on this document."
        })
      });
    }
  }, [
    isErrorDraftRelations,
    toggleNotification,
    formatMessage
  ]);
  React6.useEffect(() => {
    const localDraftRelations = /* @__PURE__ */ new Set();
    const extractDraftRelations = (data) => {
      const relations = data.connect || [];
      relations.forEach((relation) => {
        if (relation.status === "draft") {
          localDraftRelations.add(relation.id);
        }
      });
    };
    const traverseAndExtract = (data) => {
      Object.entries(data).forEach(([key, value]) => {
        if (key === "connect" && Array.isArray(value)) {
          extractDraftRelations({
            connect: value
          });
        } else if (typeof value === "object" && value !== null) {
          traverseAndExtract(value);
        }
      });
    };
    if (!documentId || modified) {
      traverseAndExtract(formValues);
      setLocalCountOfDraftRelations(localDraftRelations.size);
    }
  }, [
    documentId,
    modified,
    formValues,
    setLocalCountOfDraftRelations
  ]);
  React6.useEffect(() => {
    if (!document || !document.documentId || isListView) {
      return;
    }
    const fetchDraftRelationsCount = async () => {
      const { data, error } = await countDraftRelations({
        collectionType,
        model,
        documentId,
        params
      });
      if (error) {
        throw error;
      }
      if (data) {
        setServerCountOfDraftRelations(data.data);
      }
    };
    fetchDraftRelationsCount();
  }, [
    isListView,
    document,
    documentId,
    countDraftRelations,
    collectionType,
    model,
    params
  ]);
  const isDocumentPublished = ((document == null ? void 0 : document[PUBLISHED_AT_ATTRIBUTE_NAME]) || (meta == null ? void 0 : meta.availableStatus.some((doc) => doc[PUBLISHED_AT_ATTRIBUTE_NAME] !== null))) && (document == null ? void 0 : document.status) !== "modified";
  if (!((_a = schema == null ? void 0 : schema.options) == null ? void 0 : _a.draftAndPublish)) {
    return null;
  }
  const performPublish = async () => {
    setSubmitting(true);
    try {
      const { errors } = await validate(true, {
        status: "published"
      });
      if (errors) {
        toggleNotification({
          type: "danger",
          message: formatMessage({
            id: "content-manager.validation.error",
            defaultMessage: "There are validation errors in your document. Please fix them before saving."
          })
        });
        return;
      }
      const isPublishingRelation = rootDocumentMeta.documentId !== currentDocumentMeta.documentId;
      const res = await publish({
        collectionType,
        model,
        documentId,
        params: isPublishingRelation ? currentDocumentMeta.params : params
      }, transformData(formValues));
      if ("data" in res && collectionType !== SINGLE_TYPES) {
        if (id === "create") {
          navigate({
            pathname: `../${collectionType}/${model}/${res.data.documentId}`,
            search: rawQuery
          });
        }
      } else if ("error" in res && isBaseQueryError(res.error) && res.error.name === "ValidationError") {
        setErrors(formatValidationErrors(res.error));
      }
    } finally {
      setSubmitting(false);
      if (onPreview) {
        onPreview();
      }
    }
  };
  const totalDraftRelations = localCountOfDraftRelations + serverCountOfDraftRelations;
  const enableDraftRelationsCount = false;
  const hasDraftRelations = enableDraftRelationsCount;
  return {
    loading: isLoading,
    position: [
      "panel",
      "preview",
      "relation-modal"
    ],
    /**
    * Disabled when:
    *  - currently if you're cloning a document we don't support publish & clone at the same time.
    *  - the form is submitting
    *  - the active tab is the published tab
    *  - the document is already published & not modified
    *  - the document is being created & not modified
    *  - the user doesn't have the permission to publish
    */
    disabled: isCloning || isSubmitting || isLoadingDraftRelations || activeTab === "published" || !modified && isDocumentPublished || !modified && !(document == null ? void 0 : document.documentId) || !canPublish,
    label: formatMessage({
      id: "app.utils.publish",
      defaultMessage: "Publish"
    }),
    onClick: async () => {
      await performPublish();
    },
    dialog: hasDraftRelations ? {
      type: "dialog",
      variant: "danger",
      footer: null,
      title: formatMessage({
        id: getTranslation(`popUpwarning.warning.bulk-has-draft-relations.title`),
        defaultMessage: "Confirmation"
      }),
      content: formatMessage({
        id: getTranslation(`popUpwarning.warning.bulk-has-draft-relations.message`),
        defaultMessage: "This entry is related to {count, plural, one {# draft entry} other {# draft entries}}. Publishing it could leave broken links in your app."
      }, {
        count: totalDraftRelations
      }),
      onConfirm: async () => {
        await performPublish();
      }
    } : void 0
  };
};
PublishAction.type = "publish";
PublishAction.position = [
  "panel",
  "preview",
  "relation-modal"
];
var UpdateAction = ({ activeTab, documentId, model, collectionType, onPreview, fromPreview = false, fromRelationModal = false }) => {
  const navigate = useNavigate();
  const { toggleNotification } = useNotification();
  const { _unstableFormatValidationErrors: formatValidationErrors } = useAPIErrorHandler();
  const cloneMatch = useMatch(CLONE_PATH);
  const isCloning = cloneMatch !== null;
  const { formatMessage } = useIntl();
  const { create, update, clone, isLoading } = useDocumentActions(fromPreview, fromRelationModal);
  const [{ query, rawQuery }] = useQueryParams();
  const params = React6.useMemo(() => buildValidParams(query), [
    query
  ]);
  const isSubmitting = useForm("UpdateAction", ({ isSubmitting: isSubmitting2 }) => isSubmitting2);
  const modified = useForm("UpdateAction", ({ modified: modified2 }) => modified2);
  const setSubmitting = useForm("UpdateAction", ({ setSubmitting: setSubmitting2 }) => setSubmitting2);
  const document = useForm("UpdateAction", ({ values }) => values);
  const validate = useForm("UpdateAction", (state) => state.validate);
  const setErrors = useForm("UpdateAction", (state) => state.setErrors);
  const resetForm = useForm("PublishAction", ({ resetForm: resetForm2 }) => resetForm2);
  const rootDocumentMeta = useDocumentContext("UpdateAction", (state) => state.rootDocumentMeta);
  const currentDocumentMeta = useDocumentContext("UpdateAction", (state) => state.meta);
  const handleUpdate = React6.useCallback(async () => {
    setSubmitting(true);
    try {
      if (!modified) {
        return;
      }
      const { errors } = await validate(true, {
        status: "draft"
      });
      if (errors) {
        toggleNotification({
          type: "danger",
          message: formatMessage({
            id: "content-manager.validation.error",
            defaultMessage: "There are validation errors in your document. Please fix them before saving."
          })
        });
        return;
      }
      if (isCloning) {
        const res = await clone({
          model,
          documentId: cloneMatch.params.origin,
          params
        }, transformData(document));
        if ("data" in res) {
          navigate({
            pathname: `../${res.data.documentId}`,
            search: rawQuery
          }, {
            relative: "path"
          });
        } else if ("error" in res && isBaseQueryError(res.error) && res.error.name === "ValidationError") {
          setErrors(formatValidationErrors(res.error));
        }
      } else if (documentId || collectionType === SINGLE_TYPES) {
        const isEditingRelation = rootDocumentMeta.documentId !== currentDocumentMeta.documentId;
        const res = await update({
          collectionType,
          model,
          documentId,
          params: isEditingRelation ? currentDocumentMeta.params : params
        }, transformData(document));
        if ("error" in res && isBaseQueryError(res.error) && res.error.name === "ValidationError") {
          setErrors(formatValidationErrors(res.error));
        } else {
          resetForm();
        }
      } else {
        const res = await create({
          model,
          params
        }, transformData(document));
        if ("data" in res && collectionType !== SINGLE_TYPES) {
          navigate({
            pathname: `../${res.data.documentId}`,
            search: rawQuery
          }, {
            replace: true,
            relative: "path"
          });
        } else if ("error" in res && isBaseQueryError(res.error) && res.error.name === "ValidationError") {
          setErrors(formatValidationErrors(res.error));
        }
      }
    } finally {
      setSubmitting(false);
      if (onPreview) {
        onPreview();
      }
    }
  }, [
    clone,
    cloneMatch == null ? void 0 : cloneMatch.params.origin,
    collectionType,
    create,
    currentDocumentMeta.documentId,
    currentDocumentMeta.params,
    document,
    documentId,
    formatMessage,
    formatValidationErrors,
    isCloning,
    model,
    modified,
    navigate,
    onPreview,
    params,
    rawQuery,
    resetForm,
    rootDocumentMeta.documentId,
    setErrors,
    setSubmitting,
    toggleNotification,
    update,
    validate
  ]);
  React6.useEffect(() => {
    const handleKeyDown = (e) => {
      if (e.key === "Enter" && (e.metaKey || e.ctrlKey)) {
        e.preventDefault();
        handleUpdate();
      }
    };
    window.addEventListener("keydown", handleKeyDown);
    return () => {
      window.removeEventListener("keydown", handleKeyDown);
    };
  }, [
    handleUpdate
  ]);
  return {
    loading: isLoading,
    /**
    * Disabled when:
    * - the form is submitting
    * - the document is not modified & we're not cloning (you can save a clone entity straight away)
    * - the active tab is the published tab
    */
    disabled: isSubmitting || !modified && !isCloning || activeTab === "published",
    label: formatMessage({
      id: "global.save",
      defaultMessage: "Save"
    }),
    onClick: handleUpdate,
    position: [
      "panel",
      "preview",
      "relation-modal"
    ]
  };
};
UpdateAction.type = "update";
UpdateAction.position = [
  "panel",
  "preview",
  "relation-modal"
];
var UNPUBLISH_DRAFT_OPTIONS = {
  KEEP: "keep",
  DISCARD: "discard"
};
var UnpublishAction = ({ activeTab, documentId, model, collectionType, document }) => {
  var _a;
  const { formatMessage } = useIntl();
  const { schema } = useDoc();
  const canPublish = useDocumentRBAC("UnpublishAction", ({ canPublish: canPublish2 }) => canPublish2);
  const { unpublish } = useDocumentActions();
  const [{ query }] = useQueryParams();
  const params = React6.useMemo(() => buildValidParams(query), [
    query
  ]);
  const { toggleNotification } = useNotification();
  const [shouldKeepDraft, setShouldKeepDraft] = React6.useState(true);
  const isDocumentModified = (document == null ? void 0 : document.status) === "modified";
  const handleChange = (value) => {
    setShouldKeepDraft(value === UNPUBLISH_DRAFT_OPTIONS.KEEP);
  };
  if (!((_a = schema == null ? void 0 : schema.options) == null ? void 0 : _a.draftAndPublish)) {
    return null;
  }
  return {
    disabled: !canPublish || activeTab === "published" || (document == null ? void 0 : document.status) !== "published" && (document == null ? void 0 : document.status) !== "modified",
    label: formatMessage({
      id: "app.utils.unpublish",
      defaultMessage: "Unpublish"
    }),
    icon: (0, import_jsx_runtime5.jsx)(ForwardRef$45, {}),
    onClick: async () => {
      if (!documentId && collectionType !== SINGLE_TYPES || isDocumentModified) {
        if (!documentId) {
          console.error("You're trying to unpublish a document without an id, this is likely a bug with Strapi. Please open an issue.");
          toggleNotification({
            message: formatMessage({
              id: "content-manager.actions.unpublish.error",
              defaultMessage: "An error occurred while trying to unpublish the document."
            }),
            type: "danger"
          });
        }
        return;
      }
      await unpublish({
        collectionType,
        model,
        documentId,
        params
      });
    },
    dialog: isDocumentModified ? {
      type: "dialog",
      title: formatMessage({
        id: "app.components.ConfirmDialog.title",
        defaultMessage: "Confirmation"
      }),
      content: (0, import_jsx_runtime5.jsxs)(Flex, {
        alignItems: "flex-start",
        direction: "column",
        gap: 6,
        children: [
          (0, import_jsx_runtime5.jsxs)(Flex, {
            width: "100%",
            direction: "column",
            gap: 2,
            children: [
              (0, import_jsx_runtime5.jsx)(ForwardRef$3, {
                width: "24px",
                height: "24px",
                fill: "danger600"
              }),
              (0, import_jsx_runtime5.jsx)(Typography, {
                tag: "p",
                variant: "omega",
                textAlign: "center",
                children: formatMessage({
                  id: "content-manager.actions.unpublish.dialog.body",
                  defaultMessage: "Are you sure?"
                })
              })
            ]
          }),
          (0, import_jsx_runtime5.jsxs)(Radio.Group, {
            defaultValue: UNPUBLISH_DRAFT_OPTIONS.KEEP,
            name: "discard-options",
            "aria-label": formatMessage({
              id: "content-manager.actions.unpublish.dialog.radio-label",
              defaultMessage: "Choose an option to unpublish the document."
            }),
            onValueChange: handleChange,
            children: [
              (0, import_jsx_runtime5.jsx)(Radio.Item, {
                checked: shouldKeepDraft,
                value: UNPUBLISH_DRAFT_OPTIONS.KEEP,
                children: formatMessage({
                  id: "content-manager.actions.unpublish.dialog.option.keep-draft",
                  defaultMessage: "Keep draft"
                })
              }),
              (0, import_jsx_runtime5.jsx)(Radio.Item, {
                checked: !shouldKeepDraft,
                value: UNPUBLISH_DRAFT_OPTIONS.DISCARD,
                children: formatMessage({
                  id: "content-manager.actions.unpublish.dialog.option.replace-draft",
                  defaultMessage: "Replace draft"
                })
              })
            ]
          })
        ]
      }),
      onConfirm: async () => {
        if (!documentId && collectionType !== SINGLE_TYPES) {
          console.error("You're trying to unpublish a document without an id, this is likely a bug with Strapi. Please open an issue.");
          toggleNotification({
            message: formatMessage({
              id: "content-manager.actions.unpublish.error",
              defaultMessage: "An error occurred while trying to unpublish the document."
            }),
            type: "danger"
          });
        }
        await unpublish({
          collectionType,
          model,
          documentId,
          params
        }, !shouldKeepDraft);
      }
    } : void 0,
    variant: "danger",
    position: [
      "panel",
      "table-row"
    ]
  };
};
UnpublishAction.type = "unpublish";
UnpublishAction.position = "panel";
var DiscardAction = ({ activeTab, documentId, model, collectionType, document }) => {
  var _a;
  const { formatMessage } = useIntl();
  const { schema } = useDoc();
  const canUpdate = useDocumentRBAC("DiscardAction", ({ canUpdate: canUpdate2 }) => canUpdate2);
  const { discard, isLoading } = useDocumentActions();
  const [{ query }] = useQueryParams();
  const params = React6.useMemo(() => buildValidParams(query), [
    query
  ]);
  if (!((_a = schema == null ? void 0 : schema.options) == null ? void 0 : _a.draftAndPublish)) {
    return null;
  }
  return {
    disabled: !canUpdate || activeTab === "published" || (document == null ? void 0 : document.status) !== "modified",
    label: formatMessage({
      id: "content-manager.actions.discard.label",
      defaultMessage: "Discard changes"
    }),
    icon: (0, import_jsx_runtime5.jsx)(ForwardRef$45, {}),
    position: [
      "panel",
      "table-row"
    ],
    variant: "danger",
    dialog: {
      type: "dialog",
      title: formatMessage({
        id: "app.components.ConfirmDialog.title",
        defaultMessage: "Confirmation"
      }),
      content: (0, import_jsx_runtime5.jsxs)(Flex, {
        direction: "column",
        gap: 2,
        children: [
          (0, import_jsx_runtime5.jsx)(ForwardRef$3, {
            width: "24px",
            height: "24px",
            fill: "danger600"
          }),
          (0, import_jsx_runtime5.jsx)(Typography, {
            tag: "p",
            variant: "omega",
            textAlign: "center",
            children: formatMessage({
              id: "content-manager.actions.discard.dialog.body",
              defaultMessage: "Are you sure?"
            })
          })
        ]
      }),
      loading: isLoading,
      onConfirm: async () => {
        await discard({
          collectionType,
          model,
          documentId,
          params
        });
      }
    }
  };
};
DiscardAction.type = "discard";
DiscardAction.position = "panel";
var DEFAULT_ACTIONS = [
  PublishAction,
  UpdateAction,
  UnpublishAction,
  DiscardAction
];

export {
  PLUGIN_ID,
  PERMISSIONS,
  useDocumentContext,
  DocumentContextProvider,
  useDocumentRBAC,
  DocumentRBAC,
  useDocumentActions,
  DocumentStatus,
  CLONE_PATH,
  LIST_PATH,
  routes3 as routes,
  DocumentActions,
  DocumentActionButton,
  DocumentActionsMenu,
  DEFAULT_ACTIONS
};
//# sourceMappingURL=chunk-ER3PRL7C.js.map
